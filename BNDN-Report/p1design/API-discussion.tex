\subsection{Deciding on the External API Form}f

The two teams quickly agreed on using a RESTful JSON-based API as interface betweenf
frontend (client) and backend (server). This still left a lot to design.f
f
When designing an API it is important for it to be intuitive and attractive, as thisf
allows third-party developers, as well as our overseas colleagues, to use the API forf
their purposes. Third-party developers in general represent a huge business opportunityf
in our case, as the system requires purchases in order to actually access artifacts. Thisf
means that third-party clients may create new revenue sources for us.
f
When discussing how to best attack the problem of what a \emph{nice API} is, we found twof
options.f
f
Either we could let the API handle arbitrary datatypes or have specific services forf
every allowed datatype. The difference between the two possibilities can be illustratedf
through which services are offered by them:f
f
\begin{table}[hbt]f
    \centeringf
    \begin{tabular}{ | l | l | l | }f
        \hlinef
        \textbf{Abstraction level} & High abstraction & Low abstraction \\f
        \hlinef
        \textbf{Services provided} & files/ & movies/ \\f
        &  & songs/ \\f
        \hlinef
    \end{tabular}f
    \caption{Services offered by different abstraction levels}f
\end{table}f
f
In the high abstraction case a call to the files service may return any of the supportedf
data types, so the client can not know this for sure at the time of calling the service.f
This problem can be solved in the following ways: first off, the client discovers contentf
through a service that will also disclose the type of the content (so it is already awaref
of the type) and, secondly, the files-service itself will return the type of the contentf
as well as the content itself.f
f
In contrast, the movies- and songs-services always return movies and songs, respectively.f
f
This difference can be illustrated by looking at the services as if they were method calls.f
In this case, the files-service would have a return-type of "Object", whereas the movies-f
and songs-services would have "Movie" and "Song".f
f
The high abstraction level works like a dynamically typed language (PHP, Javascript) wouldf
work, wheras the low abstraction level works like a type-strong language like C\# or Java.f
f
\subsubsection{Cost of Change}f
In the high abstraction level service it is easy to expand the range of datatypes we offer,f
as they will be using the same API. This can with great advantage be paired with a discoveryf
service that lets clients discover the supported data-types in real-time. The cost of changef
is pretty much non-existent.f
f
This has \textbf{\emph{a lot}} of coolness factor.f
f
This approach is very dynamic and allows for updates to be rolled out seamlessly. It is, however,f
best suited for a tuple-space based database and not a relational one, such as the one we havef
chosen to work with.f
f
In a relational database, using the high abstraction would require either massive scans of onef
huge table containing all files in the system or having multiple indexes for the same, huge table,f
which would be quicker, but also take up double the space.f
f
The low abstraction level is very well suited for the relational database. Creating a table for eachf
of the services (one for movies, one for songs) is a natural choice and lets us have the desiredf
attributes for the types. Additionally searching is easier and fewer indexes are needed per tablef
(so it takes up less space).f
f
On the downside, the low abstraction level requires for entire new tables and services to be addedf
whenever we want to support a new datatype. In turn, adding new services to the API does not makef
them accessible from the clients. In order to fully roll out an update, all clients,f
including third-party ones, must be updated. This all adds up, so the cost of change is massive.f
f
\subsubsection{Final decision}f
In our application we consider the support of a new datatype to be somewhat a rare occasion. Ourf
business is centered around a very specific set of products - movies and songs - and it is withf
this line of products it will be known.f
f
With this in mind, a high cost of change is considered acceptable. With the advantages we trade in forf
it, it is a more than acceptable potential loss, so we decided on a low abstraction API, and the relationalf
data model that goes with it.
